type singleWithId = {
  id: int,
  options: list(Hero.Activatable.optionId),
  level: option(int),
  customCost: option(int),
};

let isActive = (x: Hero.Activatable.t) => Ley.List.Extra.notNull(x.active);

let isActiveM = Ley.Option.option(false, isActive);

module Convert = {
  let heroEntryToSingles = (x: Hero.Activatable.t) =>
    x.active
    |> Ley.List.map((s: Hero.Activatable.single) =>
         {
           id: x.id,
           options: s.options,
           level: s.level,
           customCost: s.customCost,
         }
       );

  let singleToSingleWithId =
      (x: Hero.Activatable.t, s: Hero.Activatable.single) => {
    id: x.id,
    options: s.options,
    level: s.level,
    customCost: s.customCost,
  };
  /* /**
    * Converts the object generated by the list item to an object that can be
    * inserted into an array of ActiveObjects.
    * @param obj The entry for which you want to convert the object.
    * @param activate The object generated by the list item.
    */
   export const convertUIStateToActiveObject =
     (activate: Record<ActivatableActivationOptions>): Record<ActiveObject> => {
       const id = AAOA.id (activate)
       const selectOptionId1 = AAOA.selectOptionId1 (activate)
       const selectOptionId2 = AAOA.selectOptionId2 (activate)
       const selectOptionId3 = AAOA.selectOptionId3 (activate)
       const input = AAOA.input (activate)
       const level = AAOA.level (activate)
       const customCost = AAOA.customCost (activate)

       return id === AdvantageId.HatredOf
         ? ActiveObject ({
             sid: selectOptionId1,
             sid2: input,
             cost: customCost,
           })
         : id === DisadvantageId.PersonalityFlaw
         ? ActiveObject ({
             sid: selectOptionId1,
             sid2: or (fmap (elemF (List<number | string> (7, 8)))
                           (selectOptionId1))
               ? input
               : None,
             cost: customCost,
           })
         : id === SpecialAbilityId.SkillSpecialization
         ? ActiveObject ({
             sid: selectOptionId1,
             sid2: alt<number | string> (input)
                                       (selectOptionId2),
             cost: customCost,
           })
         : isSome (input) && isSome (selectOptionId1)
         ? ActiveObject ({
             sid: selectOptionId1,
             sid2: input,
             sid3: selectOptionId2,
             tier: level,
             cost: customCost,
           })
         : ActiveObject ({
             sid: alt<number | string> (input)
                                       (selectOptionId1),
             sid2: then (guard (isSome (input) || isSome (selectOptionId1)))
                       (selectOptionId2),
             sid3: selectOptionId3,
             tier: level,
             cost: customCost,
           })
     } */
  /* /**
    * Generates a list of ActiveObjects based on the given instance.
    */
   export const convertActivatableToArray =
     (x: Record<ActivatableDependent>) =>
       pipe_ (
               x,
               ADA.active,
               imap (index => toActiveObjectWithId (index) (ADA.id (x)))
             ) */
  /* /**
    * Get all active items in an array.
    * @param state A state slice.
    */
   export const getActiveFromState =
     foldr (pipe (convertActivatableToArray, append)) (empty)

   export interface ActiveObjectAny extends ActiveObject {
     [key: string]: any
   } */

  let activatableOptionToSelectOptionId =
      (id: Hero.Activatable.optionId): option(Id.selectOption) =>
    switch (id) {
    | `Generic(_) as id
    | `Skill(_) as id
    | `CombatTechnique(_) as id
    | `Spell(_) as id
    | `Cantrip(_) as id
    | `LiturgicalChant(_) as id
    | `Blessing(_) as id => Some(id)
    | `CustomInput(_) => None
    };
};

module Accessors = {
  open Static;

  let name = x =>
    switch (x) {
    | Advantage(y) => y.name
    | Disadvantage(y) => y.name
    | SpecialAbility(y) => y.name
    };

  let selectOptions = x =>
    switch (x) {
    | Advantage(y) => y.selectOptions
    | Disadvantage(y) => y.selectOptions
    | SpecialAbility(y) => y.selectOptions
    };

  let input = x =>
    switch (x) {
    | Advantage(y) => y.input
    | Disadvantage(y) => y.input
    | SpecialAbility(y) => y.input
    };

  let apValue = x =>
    switch (x) {
    | Advantage(y) => y.apValue
    | Disadvantage(y) => y.apValue
    | SpecialAbility(y) => y.apValue
    };
};

module SelectOptions = {
  open Static.SelectOption;
  open Ley.Option;
  open Ley.Option.Functor;
  open Ley.Option.Monad;

  let getSelectOption = (x, id) =>
    id
    |> Convert.activatableOptionToSelectOptionId
    >>= Ley.Function.flip(SelectOptionMap.lookup, Accessors.selectOptions(x));

  /**
   * Get a selection option's name with the given id from given wiki entry.
   * Returns `None` if not found.
   */
  let getSelectOptionName = (x, id) =>
    id |> getSelectOption(x) <&> (y => y.name);

  /**
   * Get a selection option's cost with the given id from given wiki entry.
   * Returns `None` if not found.
   */
  let getSelectOptionCost = (x, id) =>
    id |> getSelectOption(x) >>= (y => y.cost);

  /**
   * Get all select option IDs from the given entry at the passed index.
   */
  let getActiveOptions = (index, x: Hero.Activatable.t) =>
    x.active
    |> mapOption((y: Hero.Activatable.single) =>
         Ley.List.Safe.atMay(y.options, index)
       );

  /**
   * Get all first select option IDs from the given entry.
   */
  let getActiveOptions1 = (x: Hero.Activatable.t) =>
    x.active
    |> mapOption((y: Hero.Activatable.single) => y.options |> listToOption);

  /**
   * Get all second select option IDs from the given entry.
   */
  let getActiveOptions2 = getActiveOptions(1);
  // type SecondarySelections = OrderedMap<number | string, List<string | number>>
  //
  // /**
  //  * Get all `ActiveObject.sid2` values from the given instance, sorted by
  //  * `ActiveObject.sid` in Map.
  //  * @param entry
  //  */
  // export const getActiveSecondarySelections =
  //   fmap (pipe (
  //               ADA.active,
  //               foldl ((map: SecondarySelections) => (selection: Record<ActiveObject>) =>
  //                       fromOption (map)
  //                                 (liftM2<string | number, string | number, SecondarySelections>
  //                                   (id => id2 => alter<List<string | number>>
  //                                     (pipe (
  //                                       fmap (consF (id2)),
  //                                       altF (Some (List (id2)))
  //                                     ))
  //                                     (id)
  //                                     (map))
  //                                   (AOA.sid (selection))
  //                                   (AOA.sid2 (selection))))
  //                     (OrderedMap.empty)
  //             ))
  //
  // /**
  //  * Get all `DependencyObject.sid` values from the given instance.
  //  * @param obj The entry.
  //  */
  // export const getRequiredSelections:
  //   (m: Option<Record<ActivatableDependent>>) => Option<List<string | number | List<number>>> =
  //     fmap (pipe (
  //       ADA.dependencies,
  //       mapOption<ActivatableDependency, string | number | List<number>> (pipe (
  //         ensure (isRecord),
  //         bindF (DependencyObject.A.sid)
  //       ))
  //     ))
};

let getOption = (index, heroEntry) =>
  Ley.List.Safe.atMay(heroEntry.options, index);
let getOption1 = heroEntry => heroEntry.options |> Ley.Option.listToOption;
let getOption2 = getOption(1);
let getOption3 = getOption(2);

let getCustomInput = (option: Hero.Activatable.optionId) =>
  switch (option) {
  | `CustomInput(x) => Some(x)
  | `Generic(_)
  | `Skill(_)
  | `CombatTechnique(_)
  | `Spell(_)
  | `LiturgicalChant(_)
  | `Cantrip(_)
  | `Blessing(_) => None
  };

let getGenericId = (option: Hero.Activatable.optionId) =>
  switch (option) {
  | `Generic(x) => Some(x)
  | `Skill(_)
  | `CombatTechnique(_)
  | `Spell(_)
  | `LiturgicalChant(_)
  | `Cantrip(_)
  | `Blessing(_)
  | `CustomInput(_) => None
  };

let lookupMap = (k, mp, f) =>
  Ley.Option.Functor.(f <$> Ley.IntMap.lookup(k, mp));

let getSkillFromOption =
    (staticData: Static.t, option: Hero.Activatable.optionId) =>
  switch (option) {
  | `Skill(id) => Ley.IntMap.lookup(id, staticData.skills)
  | `Generic(_)
  | `CombatTechnique(_)
  | `Spell(_)
  | `LiturgicalChant(_)
  | `Cantrip(_)
  | `Blessing(_)
  | `CustomInput(_) => None
  };

module Names = {
  open Ley.Option;
  open Ley.Option.Functor;
  open Ley.Option.Monad;
  open Static;
  open Ley.Function;

  let getDefaultNameAddition = (staticEntry, heroEntry) => {
    let input = Accessors.input(staticEntry);
    let selectOptions = Accessors.selectOptions(staticEntry);

    let sid = heroEntry |> getOption1;
    let sid2 = heroEntry |> getOption2;

    switch (input, sid, sid2) {
    // Text input
    | (Some(_), Some(`CustomInput(str)), None) => Some(str)
    // Select option and text input
    | (
        Some(_),
        Some(
          `Generic(_) as id | `Skill(_) as id | `CombatTechnique(_) as id |
          `Spell(_) as id |
          `LiturgicalChant(_) as id |
          `Cantrip(_) as id |
          `Blessing(_) as id,
        ),
        Some(`CustomInput(str)),
      )
        when SelectOption.SelectOptionMap.size(selectOptions) > 0 =>
      Some(
        (
          id
          |> SelectOptions.getSelectOptionName(staticEntry)
          |> fromOption("")
        )
        ++ ": "
        ++ str,
      )
    // Plain select option
    | (
        None,
        Some(
          `Generic(_) as id | `Skill(_) as id | `CombatTechnique(_) as id |
          `Spell(_) as id |
          `LiturgicalChant(_) as id |
          `Cantrip(_) as id |
          `Blessing(_) as id,
        ),
        None,
      ) =>
      SelectOptions.getSelectOptionName(staticEntry, id)
    | _ => None
    };
  };

  /**
   * A lot of entries have customization options: Text input, select option or
   * both. This function creates a string that can be appended to the `name`
   * property of the respective record to create the full active name.
   */
  let getEntrySpecificNameAddition = (staticData, staticEntry, heroEntry) =>
    switch (staticEntry) {
    | Advantage(entry) =>
      switch (Id.advantageFromInt(entry.id)) {
      | Aptitude
      | ExceptionalSkill =>
        heroEntry
        |> getOption1
        >>= (
          sid =>
            switch (sid) {
            | `Skill(id) => lookupMap(id, staticData.skills, x => x.name)
            | `Spell(id) => lookupMap(id, staticData.spells, x => x.name)
            | `LiturgicalChant(id) =>
              lookupMap(id, staticData.liturgicalChants, x => x.name)
            | `Generic(_)
            | `CombatTechnique(_)
            | `Cantrip(_)
            | `Blessing(_)
            | `CustomInput(_) => None
            }
        )
      | ExceptionalCombatTechnique
      | WeaponAptitude =>
        heroEntry
        |> getOption1
        >>= (
          sid =>
            switch (sid) {
            | `CombatTechnique(id) =>
              lookupMap(id, staticData.combatTechniques, x => x.name)
            | `Generic(_)
            | `Skill(_)
            | `Spell(_)
            | `LiturgicalChant(_)
            | `Cantrip(_)
            | `Blessing(_)
            | `CustomInput(_) => None
            }
        )
      | HatredFor =>
        heroEntry
        |> getOption1
        >>= SelectOptions.getSelectOption(staticEntry)
        |> liftM2(
             (type_, frequency: Static.SelectOption.t) =>
               type_ ++ " (" ++ frequency.name ++ ")",
             getOption2(heroEntry) >>= getCustomInput,
           )
      | _ => getDefaultNameAddition(staticEntry, heroEntry)
      }
    | Disadvantage(entry) =>
      switch (Id.disadvantageFromInt(entry.id)) {
      | Incompetent =>
        heroEntry
        |> getOption1
        >>= getSkillFromOption(staticData)
        <&> (x => x.name)
      | PersonalityFlaw =>
        heroEntry
        |> getOption1
        >>= SelectOptions.getSelectOption(staticEntry)
        <&> (
          option1 =>
            (
              switch (option1.id) {
              // Get the input if Prejudice or Unworldly is selected
              | `Generic(7 | 8) => heroEntry |> getOption2 >>= getCustomInput
              // Otherwise ignore any additional options
              | `Generic(_)
              | `Skill(_)
              | `CombatTechnique(_)
              | `Spell(_)
              | `LiturgicalChant(_)
              | `Cantrip(_)
              | `Blessing(_)
              | `SpecialAbility(_) => None
              }
            )
            |> option(option1.name, specialInput =>
                 option1.name ++ ": " ++ specialInput
               )
        )
      | _ => getDefaultNameAddition(staticEntry, heroEntry)
      }
    | SpecialAbility(entry) =>
      switch (Id.specialAbilityFromInt(entry.id)) {
      | AdaptionZauber
      | FavoriteSpellwork =>
        heroEntry
        |> getOption1
        >>= (
          sid =>
            switch (sid) {
            | `Spell(id) => lookupMap(id, staticData.spells, x => x.name)
            | `Generic(_)
            | `Skill(_)
            | `CombatTechnique(_)
            | `LiturgicalChant(_)
            | `Cantrip(_)
            | `Blessing(_)
            | `CustomInput(_) => None
            }
        )
      | TraditionSavant
      | Forschungsgebiet
      | Expertenwissen
      | Wissensdurst
      | Recherchegespuer =>
        heroEntry
        |> getOption1
        >>= getSkillFromOption(staticData)
        <&> (x => x.name)
      | Lieblingsliturgie =>
        heroEntry
        |> getOption1
        >>= (
          sid =>
            switch (sid) {
            | `LiturgicalChant(id) =>
              lookupMap(id, staticData.liturgicalChants, x => x.name)
            | `Generic(_)
            | `Skill(_)
            | `CombatTechnique(_)
            | `Spell(_)
            | `Cantrip(_)
            | `Blessing(_)
            | `CustomInput(_) => None
            }
        )
      | SkillSpecialization =>
        heroEntry
        |> getOption1
        >>= getSkillFromOption(staticData)
        >>= (
          skill =>
            heroEntry
            |> getOption2
            >>= (
              option2 =>
                (
                  switch (option2) {
                  // If input string use input
                  | `CustomInput(x) => Some(x)
                  // Otherwise lookup application name
                  | `Generic(id) =>
                    skill.applications
                    |> Ley.IntMap.Foldable.find((a: Skill.application) =>
                         a.id === id
                       )
                    <&> (a => a.name)
                  | `Skill(_)
                  | `CombatTechnique(_)
                  | `Spell(_)
                  | `LiturgicalChant(_)
                  | `Cantrip(_)
                  | `Blessing(_) => None
                  }
                )
                // Merge skill name and application name
                <&> (appName => skill.name ++ ": " ++ appName)
            )
        )
      | Exorzist =>
        switch (heroEntry.level) {
        | Some(1) =>
          heroEntry
          |> getOption1
          >>= SelectOptions.getSelectOptionName(staticEntry)
        | _ => None
        }
      | SpellEnhancement as entryId
      | ChantEnhancement as entryId =>
        heroEntry
        |> getOption1
        >>= SelectOptions.getSelectOption(staticEntry)
        >>= (
          enhancement =>
            enhancement.enhancementTarget
            >>= (
              id =>
                (
                  switch (entryId) {
                  | SpellEnhancement =>
                    Ley.IntMap.lookup(id, staticData.spells) <&> (x => x.name)
                  | _ =>
                    Ley.IntMap.lookup(id, staticData.liturgicalChants)
                    <&> (x => x.name)
                  }
                )
                <&> (targetName => targetName ++ ": " ++ enhancement.name)
            )
        )
      | TraditionArcaneBard =>
        heroEntry
        |> getOption1
        >>= getGenericId
        >>= flip(Ley.IntMap.lookup, staticData.arcaneBardTraditions)
      | TraditionArcaneDancer =>
        heroEntry
        |> getOption1
        >>= getGenericId
        >>= flip(Ley.IntMap.lookup, staticData.arcaneDancerTraditions)
      | LanguageSpecializations =>
        liftM2(
          SelectOptions.getSelectOption,
          Ley.IntMap.lookup(
            Id.specialAbilityToInt(Language),
            staticData.specialAbilities,
          )
          <&> (specialAbility => SpecialAbility(specialAbility)),
          getOption1(heroEntry),
        )
        |> join
        >>= (
          language =>
            heroEntry
            |> getOption2
            >>= (
              option2 =>
                (
                  switch (option2) {
                  | `CustomInput(str) => Some(str)
                  | `Generic(specializationId) =>
                    language.specializations
                    >>= (
                      specializations =>
                        Ley.List.Safe.atMay(
                          specializations,
                          specializationId - 1,
                        )
                    )
                  | `Skill(_)
                  | `CombatTechnique(_)
                  | `Spell(_)
                  | `LiturgicalChant(_)
                  | `Cantrip(_)
                  | `Blessing(_) => None
                  }
                )
                <&> (specialization => language.name ++ ": " ++ specialization)
            )
        )
      | Fachwissen =>
        heroEntry
        |> getOption1
        >>= getSkillFromOption(staticData)
        >>= (
          skill => {
            let applications =
              skill.applications
              |> Ley.IntMap.filter((app: Skill.application) =>
                   app.prerequisite |> isNone
                 );

            [heroEntry |> getOption2, heroEntry |> getOption3]
            |> mapOption(option =>
                 option
                 >>= getGenericId
                 >>= (
                   opt =>
                     applications
                     |> Ley.IntMap.Foldable.find((app: Skill.application) =>
                          app.id === opt
                        )
                     <&> (app => app.name)
                 )
               )
            |> ensure(apps => apps |> Ley.List.Foldable.length |> (===)(2))
            <&> (
              apps =>
                apps
                |> AdvancedFiltering.sortStrings(staticData)
                |> Intl.ListFormat.format(Conjunction, staticData)
                |> (appsStr => skill.name ++ ": " ++ appsStr)
            );
          }
        )
      | _ => getDefaultNameAddition(staticEntry, heroEntry)
      }
    };

  let getDisAdvLevelStr = level =>
    level |> Integers.intToRoman |> fromOption(Ley.Int.show(level));

  let getSpecialAbilityLevelStr = level =>
    (level > 1 ? "I" ++ Chars.nobr ++ "â€“" ++ Chars.nobr : "")
    ++ getDisAdvLevelStr(level);

  /**
   * Gets the level string that hast to be appended (with a non-breaking space!)
   * to the name. This string is aware of differences between dis/advantages and
   *  special abilties as well as it handles the Native Tongue level for
   * languages.
   */
  let getLevelName = (staticData, staticEntry, singleHeroEntry) =>
    switch (staticEntry, singleHeroEntry.level) {
    | (Advantage(_), Some(level))
    | (Disadvantage(_), Some(level)) => Some(getDisAdvLevelStr(level))
    | (SpecialAbility(staticEntry), Some(level)) =>
      switch (Id.specialAbilityFromInt(staticEntry.id)) {
      // Language level 4 = Native Tongue and thus needs a special name
      | Language when level === 4 =>
        Some(staticData.messages.specialabilities_nativetonguelevel)
      | _ => Some(getSpecialAbilityLevelStr(level))
      }
    | _ => None
    };

  /**
   * Some entries cannot use the default `name` property from wiki entries. The
   * value returned by may not use the default `name` property. For all entries
   * that do not need to handle a specific display format, the default `name`
   * property is used.
   */
  let getEntrySpecificNameReplacements =
      (~addLevelToName, staticEntry, nameAddition, levelName) => {
    let name = Accessors.name(staticEntry);

    let flatLevelName =
      addLevelToName ? option("", (++)(Chars.nbsp), levelName) : "";

    let mapNameAddition = f => option(name, f, nameAddition);

    let mapDefaultWithParens = () =>
      mapNameAddition(add => name ++ " (" ++ add ++ ")");

    let mapDefaultWithoutParens = () =>
      mapNameAddition(add => name ++ " " ++ add);

    let addSndInParens = snd =>
      Ley.List.Extra.replaceStr(")", ": " ++ snd ++ ")");

    switch (staticEntry) {
    | Advantage(entry) =>
      switch (Id.advantageFromInt(entry.id)) {
      | ImmunityToPoison
      | ImmunityToDisease
      | HatredFor => mapDefaultWithoutParens()
      | _ => mapDefaultWithParens() ++ flatLevelName
      }
    | Disadvantage(entry) =>
      switch (Id.disadvantageFromInt(entry.id)) {
      | AfraidOf => mapDefaultWithoutParens() ++ flatLevelName
      | Principles
      | Obligations =>
        option(
          name ++ flatLevelName,
          nameAddition => name ++ flatLevelName ++ " (" ++ nameAddition ++ ")",
          nameAddition,
        )
      | _ => mapDefaultWithParens() ++ flatLevelName
      }
    | SpecialAbility(entry) =>
      switch (Id.specialAbilityFromInt(entry.id)) {
      | GebieterDesAspekts => mapDefaultWithoutParens()
      | TraditionArcaneBard
      | TraditionArcaneDancer
      | TraditionSavant => mapNameAddition(flip(addSndInParens, name))
      | _ => mapDefaultWithParens() ++ flatLevelName
      }
    };
  };

  type combinedName = {
    name: string,
    baseName: string,
    addName: option(string),
    levelName: option(string),
  };

  /**
   * Returns name, splitted and combined, of advantage/disadvantage/special
   * ability as a Option (in case the wiki entry does not exist).
   */
  let getName = (~addLevelToName, staticData, staticEntry, heroEntry) => {
    let addName =
      getEntrySpecificNameAddition(staticData, staticEntry, heroEntry);

    let levelName = getLevelName(staticData, staticEntry, heroEntry);

    let fullName =
      getEntrySpecificNameReplacements(
        ~addLevelToName,
        staticEntry,
        addName,
        levelName,
      );

    {
      name: fullName,
      baseName: Accessors.name(staticEntry),
      addName,
      levelName,
    };
  };
  /*
   /**
    * Returns the name of the given object. If the object is a string, it returns
    * the string.
    */
   export const getFullName =
     (obj: string | ActiveActivatable): string => {
       if (typeof obj === "string") {
         return obj
       }

       return obj.nameAndCost.naming.name
     }

   /**
    * Accepts the full special ability name and returns only the text between
    * parentheses. If no parentheses were found, returns an empty string.
    */
   export const getBracketedNameFromFullName =
     (full_name: string): string => {
       const result = /\((?<subname>.+)\)/u .exec (full_name)

       if (result === null || result .groups === undefined) {
         return ""
       }

       return result .groups .subname
     }

   /**
    * `compressList :: L10n -> [ActiveActivatable] -> String`
    *
    * Takes a list of active Activatables and merges them together. Used to display
    * lists of Activatables on character sheet.
    */
   export const compressList =
     (staticData: StaticDataRecord) =>
     (xs: List<Record<ActiveActivatable>>): string => {
       const grouped_xs =
         elems (groupByKey<Record<ActiveActivatable>, string> (AAA_.id) (xs))

       return pipe (
                     map (
                       ifElse<List<Record<ActiveActivatable>>>
                         (xs_group => flength (xs_group) === 1)
                         (pipe (listToOption, Option ("") (AAA_.name)))
                         (xs_group => pipe (
                                             map ((x: Record<ActiveActivatable>) => {
                                               const levelPart =
                                                 pipe (
                                                       AAA_.level,
                                                       fmap (pipe (toRoman, appendStr (" "))),
                                                       fromOption ("")
                                                     )
                                                     (x)

                                               const selectOptionPart =
                                                 fromOption ("") (AAA_.addName (x))

                                               return selectOptionPart + levelPart
                                             }),
                                             sortStrings (staticData),
                                             intercalate (", "),
                                             x => ` (${x})`,
                                             x => option ("")
                                                       ((r: Record<ActiveActivatable>) =>
                                                         AAA_.baseName (r) + x)
                                                       (listToOption (xs_group))
                                           )
                                           (xs_group))
                     ),
                     sortStrings (staticData),
                     intercalate (", ")
                   )
                   (grouped_xs)
     }
   */
};

module AdventurePoints = {
  open Ley.Option;
  open Ley.Option.Functor;
  open Ley.Option.Monad;
  open Static;
  open Ley.Function;

  type combinedApValue = {
    apValue: int,
    isAutomatic: bool,
  };

  let ensureFlat =
    fun
    | Static.Advantage.Flat(x) => Some(x)
    | Static.Advantage.PerLevel(_) => None;

  let ensurePerLevel =
    fun
    | Static.Advantage.Flat(_) => None
    | Static.Advantage.PerLevel(x) => Some(x);

  let getDefaultEntryCost = (staticEntry, singleHeroEntry) => {
    open Ley.List;

    let sid1 = singleHeroEntry |> getOption1;
    let level = fromOption(1, singleHeroEntry.level);
    let apValue =
      staticEntry
      |> Accessors.apValue
      |> fromOption(Static.Advantage.Flat(0));

    let optionApValue =
      sid1 >>= SelectOptions.getSelectOptionCost(staticEntry);

    switch (optionApValue) {
    | Some(x) => Some(x)
    | None =>
      switch (apValue) {
      | Flat(x) => Some(x * level)
      | PerLevel(xs) =>
        switch (staticEntry) {
        | Advantage(_)
        | Disadvantage(_) => Ley.List.Safe.atMay(xs, level - 1)
        | SpecialAbility(_) =>
          xs
          |> take(Ley.Int.max(1, level))
          |> Ley.List.Foldable.sum
          |> (x => Some(x))
        }
      }
    };
  };

  /**
   * Returns the value(s) how the spent AP value would change after removing the
   * respective entry.
   *
   * @param isEntryToAdd If `entry` has not been added to the list of active
   * entries yet, this must be `true`, otherwise `false`.
   */
  let getEntrySpecificCost =
      (
        ~isEntryToAdd,
        staticData,
        hero: Hero.t,
        staticEntry,
        heroEntry: Hero.Activatable.t,
        singleHeroEntry,
      ) => {
    open Ley.List;

    let sid1 = singleHeroEntry |> getOption1;
    let level = singleHeroEntry.level;
    let apValue =
      staticEntry
      |> Accessors.apValue
      |> fromOption(Static.Advantage.Flat(0));

    switch (staticEntry) {
    | Advantage(entry) =>
      switch (Id.advantageFromInt(entry.id)) {
      | Aptitude
      | ExceptionalSkill =>
        singleHeroEntry
        |> getOption1
        >>= (
          sid =>
            switch (sid, apValue) {
            | (`Skill(id), PerLevel(apValues)) =>
              Ley.IntMap.lookup(id, staticData.skills)
              >>= (
                static => Ley.List.Safe.atMay(apValues, IC.icToIx(static.ic))
              )
            | (`Spell(id), PerLevel(apValues)) =>
              Ley.IntMap.lookup(id, staticData.spells)
              >>= (
                static => Ley.List.Safe.atMay(apValues, IC.icToIx(static.ic))
              )
            | (`LiturgicalChant(id), PerLevel(apValues)) =>
              Ley.IntMap.lookup(id, staticData.liturgicalChants)
              >>= (
                static => Ley.List.Safe.atMay(apValues, IC.icToIx(static.ic))
              )
            | _ => None
            }
        )
      | ExceptionalCombatTechnique
      | WeaponAptitude =>
        singleHeroEntry
        |> getOption1
        >>= (
          sid =>
            switch (sid, apValue) {
            | (`CombatTechnique(id), PerLevel(apValues)) =>
              Ley.IntMap.lookup(id, staticData.combatTechniques)
              >>= (
                static => Ley.List.Safe.atMay(apValues, IC.icToIx(static.ic))
              )
            | _ => None
            }
        )
      | _ => getDefaultEntryCost(staticEntry, singleHeroEntry)
      }
    | Disadvantage(entry) =>
      switch (Id.disadvantageFromInt(entry.id)) {
      | PersonalityFlaw =>
        switch (sid1) {
        | Some(`Generic(selected_option)) =>
          let matchOption = (target_option, current) =>
            switch (current) {
            | Some(`Generic(x)) => x === target_option
            | _ => false
            };

          let isPersonalityFlawNotPaid = (target_option, paid_entries_max) =>
            target_option === selected_option
            && Ley.List.countBy(
                 (e: Hero.Activatable.single) =>
                   e.options
                   |> listToOption
                   |> matchOption(target_option)
                   // Entries with custom cost are ignored for the rule
                   && isNone(e.customCost),
                 heroEntry.active,
               )
            > (isEntryToAdd ? paid_entries_max - 1 : paid_entries_max);

          // 7 = "Prejudice" => more than one entry possible
          // more than one entry of Prejudice does not contribute to AP spent
          //
          // 8 = "Unworldly" => more than one entry possible
          // more than two entries of Unworldly do not contribute to AP spent
          //
          // In both cases, removing the entry would not change AP so it has to
          // return 0.
          if (isPersonalityFlawNotPaid(7, 1)
              || isPersonalityFlawNotPaid(8, 2)) {
            Some(0);
          } else {
            SelectOptions.getSelectOptionCost(
              staticEntry,
              `Generic(selected_option),
            );
          };
        | _ => None
        }
      | Principles
      | Obligations =>
        level
        >>= (
          level => {
            // This is the highest and the second-highest level of this entry at the
            // moment.
            let (maxLevel, sndMaxLevel) =
              heroEntry.active
              |> Ley.List.Foldable.foldr(
                   (active: Hero.Activatable.single, (prevMax, prevSndMax)) =>
                     switch (active.level, active.customCost) {
                     // Only get the maximum from the current and the previous level, if
                     // the current has no custom cost
                     | (Some(activeLevel), None) =>
                       if (activeLevel > prevMax) {
                         (activeLevel, prevMax);
                       } else {
                         (prevMax, prevSndMax);
                       }
                     // Otherwise always return the previous max
                     | _ => (prevMax, prevSndMax)
                     },
                   (0, 0),
                 );

            // If there is more than one entry on the same level if this entry is
            // active, it won't affect AP spent at all. Thus, if the entry is to
            // be added, there must be at least one (> 0) entry for this rule to
            // take effect.
            //
            // If the entry is not the one with the highest level, adding or
            // removing it won't affect AP spent at all
            if (maxLevel > level
                || countBy(
                     (e: Hero.Activatable.single) =>
                       Ley.Option.Foldable.elem(level, e.level),
                     heroEntry.active,
                   )
                > (isEntryToAdd ? 0 : 1)) {
              None;
            } else {
              // Otherwise, the level difference results in the cost.
              apValue |> ensureFlat <&> ( * )(level - sndMaxLevel);
            };
          }
        )
      | BadHabit =>
        apValue
        |> ensureFlat
        |> Ley.Option.Foldable.find(_ =>
             countBy(
               (e: Hero.Activatable.single) => isNone(e.customCost),
               heroEntry.active,
             )
             > (isEntryToAdd ? 2 : 3)
           )
      | Incompetent =>
        singleHeroEntry
        |> getOption1
        >>= (
          sid =>
            switch (sid, apValue) {
            | (`Skill(id), PerLevel(apValues)) =>
              Ley.IntMap.lookup(id, staticData.skills)
              >>= (
                static => Ley.List.Safe.atMay(apValues, IC.icToIx(static.ic))
              )
            | _ => None
            }
        )
      | _ => getDefaultEntryCost(staticEntry, singleHeroEntry)
      }
    | SpecialAbility(entry) =>
      switch (Id.specialAbilityFromInt(entry.id)) {
      | SkillSpecialization =>
        sid1
        >>= getSkillFromOption(staticData)
        <&> (
          skill =>
            // Multiply number of final occurences of the
            // same skill...
            (
              countBy(
                (e: Hero.Activatable.single) =>
                  e.options
                  |> listToOption
                  |> Ley.Option.Foldable.elem(`Skill(skill.id))
                  // Entries with custom cost are ignored for the rule
                  && isNone(e.customCost),
                heroEntry.active,
              )
              + (isEntryToAdd ? 1 : 0)
            )
            // ...with the skill's IC
            * IC.getAPForActivatation(skill.ic)
        )
      | Language =>
        level
        >>= (
          fun
          // Native Tongue (level 4) does not cost anything
          | 4 => Some(0)
          | level => apValue |> ensureFlat <&> ( * )(level)
        )
      | PropertyKnowledge
      | AspectKnowledge =>
        apValue
        |> ensurePerLevel
        >>= (
          apPerLevel => {
            // Ignore custom cost activations in terms of calculated cost
            let amountActive =
              countBy(
                (e: Hero.Activatable.single) => isNone(e.customCost),
                heroEntry.active,
              );

            let index = amountActive + (isEntryToAdd ? 0 : (-1));

            Ley.List.Safe.atMay(apPerLevel, index);
          }
        )
      | TraditionWitches =>
        // There are two disadvantages that, when active, decrease the cost of
        // this tradition by 10 AP each
        let decreaseCost = (id, cost) =>
          hero.disadvantages |> Ley.IntMap.lookup(id) |> isActiveM
            ? cost - 10 : cost;

        apValue
        |> ensureFlat
        <&> (
          flatAp =>
            flatAp
            |> decreaseCost(Id.disadvantageToInt(NoFlyingBalm))
            |> decreaseCost(Id.disadvantageToInt(NoFamiliar))
        );
      | AdaptionZauber
      | FavoriteSpellwork =>
        singleHeroEntry
        |> getOption1
        >>= (
          sid =>
            switch (sid, apValue) {
            | (`Spell(id), PerLevel(apValues)) =>
              Ley.IntMap.lookup(id, staticData.spells)
              >>= (
                static => Ley.List.Safe.atMay(apValues, IC.icToIx(static.ic))
              )
            | _ => None
            }
        )
      | Lieblingsliturgie =>
        singleHeroEntry
        |> getOption1
        >>= (
          sid =>
            switch (sid, apValue) {
            | (`LiturgicalChant(id), PerLevel(apValues)) =>
              Ley.IntMap.lookup(id, staticData.liturgicalChants)
              >>= (
                static => Ley.List.Safe.atMay(apValues, IC.icToIx(static.ic))
              )
            | _ => None
            }
        )
      | Forschungsgebiet
      | Expertenwissen
      | Wissensdurst
      | WegDerGelehrten
      | WegDerKuenstlerin
      | Fachwissen
      | Handwerkskunst
      | KindDerNatur
      | KoerperlichesGeschick
      | SozialeKompetenz
      | Universalgenie =>
        singleHeroEntry
        |> getOption1
        >>= (
          sid =>
            switch (sid, apValue) {
            | (`Skill(id), PerLevel(apValues)) =>
              Ley.IntMap.lookup(id, staticData.skills)
              >>= (
                static => Ley.List.Safe.atMay(apValues, IC.icToIx(static.ic))
              )
            | _ => None
            }
        )
      | Recherchegespuer =>
        // The AP cost for this SA consist of two parts: AP based on the IC of
        // the main subject (from "SA_531"/Wissensdurst) in addition to AP based
        // on the IC of the side subject selected in this SA.

        hero.specialAbilities
        |> Ley.IntMap.lookup(Id.specialAbilityToInt(Wissensdurst))
        >>= (
          wissensdurst =>
            apValue
            |> ensurePerLevel
            >>= (
              apPerLevel => {
                let getCostFromHeroEntry = entry =>
                  entry
                  |> getOption1
                  >>= getSkillFromOption(staticData)
                  >>= (
                    skill =>
                      Ley.List.Safe.atMay(apPerLevel, IC.icToIx(skill.ic))
                  );

                liftM2(
                  (+),
                  // Cost for side subject
                  getCostFromHeroEntry(singleHeroEntry),
                  // Cost for main subject from Wissensdurst
                  wissensdurst.active
                  |> listToOption
                  >>= (
                    fst =>
                      fst
                      |> Convert.singleToSingleWithId(heroEntry)
                      |> getCostFromHeroEntry
                  ),
                );
              }
            )
        )
      | LanguageSpecializations =>
        apValue
        |> ensureFlat
        >>= (
          flatAp =>
            sid1
            >>= getGenericId
            >>= (
              languageId =>
                hero.specialAbilities
                |> Ley.IntMap.lookup(Id.specialAbilityToInt(Language))
                >>= (
                  language =>
                    language.active
                    |> Ley.List.Foldable.find((e: Hero.Activatable.single) =>
                         e.options
                         |> listToOption
                         >>= getGenericId
                         |> Ley.Option.Foldable.elem(languageId)
                       )
                    >>= (
                      selectedLanguage =>
                        selectedLanguage.level
                        <&> (
                          fun
                          | 4 => 0
                          | _ => flatAp
                        )
                    )
                )
            )
        )
      | _ => getDefaultEntryCost(staticEntry, singleHeroEntry)
      }
    };
  };

  /**
   * Returns the AP you get when removing the ActiveObject.
   *
   * @param isEntryToAdd If `entry` has not been added to the list of active
   * entries yet, this must be `true`, otherwise `false`.
   */
  let getApValue =
      (
        ~isEntryToAdd,
        ~automaticAdvantages,
        staticData,
        hero: Hero.t,
        staticEntry,
        heroEntry: Hero.Activatable.t,
        singleHeroEntry,
      ) => {
    let isAutomatic = Ley.List.elem(singleHeroEntry.id, automaticAdvantages);

    let modifyAbs =
      switch (staticEntry) {
      | Disadvantage(_) => Ley.Int.negate
      | Advantage(_)
      | SpecialAbility(_) => id
      };

    switch (singleHeroEntry.customCost) {
    | Some(customCost) => {apValue: modifyAbs(customCost), isAutomatic}
    | None =>
      getEntrySpecificCost(
        ~isEntryToAdd,
        staticData,
        hero,
        staticEntry,
        heroEntry,
        singleHeroEntry,
      )
      |> fromOption(0)
      |> modifyAbs
      |> (apValue => {apValue, isAutomatic})
    };
  };
};

module ExtendedStyle = {
  open Ley.Option.Functor;
  open Ley.Option.Monad;

  type getterSetter = (
    Hero.t => list(Hero.styleDependency),
    (list(Hero.styleDependency), Hero.t) => Hero.t,
  );

  /**
   * Returns a getter and a setter for the appropiate dependency list for the
   * passed style special ability or extended special ability.
   */
  let getStyleDependenciesAcc = (style: Static.SpecialAbility.t) =>
    switch (Id.specialAbilityGroupFromInt(style.gr)) {
    | CombatStylesArmed
    | CombatStylesUnarmed
    | CombatExtended =>
      Some((
        ((hero: Hero.t) => hero.combatStyleDependencies),
        (
          (dependencies, hero: Hero.t) => {
            ...hero,
            combatStyleDependencies: dependencies,
          }
        ),
      ))
    | MagicalStyles
    | MagicalExtended =>
      Some((
        ((hero: Hero.t) => hero.magicalStyleDependencies),
        (
          (dependencies, hero: Hero.t) => {
            ...hero,
            magicalStyleDependencies: dependencies,
          }
        ),
      ))
    | BlessedStyles
    | KarmaExtended =>
      Some((
        ((hero: Hero.t) => hero.blessedStyleDependencies),
        (
          (dependencies, hero: Hero.t) => {
            ...hero,
            blessedStyleDependencies: dependencies,
          }
        ),
      ))
    | SkillStyles
    | SkillExtended =>
      Some((
        ((hero: Hero.t) => hero.skillStyleDependencies),
        (
          (dependencies, hero: Hero.t) => {
            ...hero,
            skillStyleDependencies: dependencies,
          }
        ),
      ))
    | _ => None
    };

  /**
   * If a style has multiple possible extended special abilities in one slot,
   * it has more options to offer. If such a slot is used and a new style
   * dependency with the used slot, but not multiple possibilities, is added,
   * this function will shift the use to the style dependency with the fixed
   * option instead, so there are more options left in the end.
   */
  let moveActiveInListToNew = (newxs, x: Hero.styleDependency) =>
    switch (x.id, x.active) {
    // If the dependency has got a list of possible ids and is used, we check
    // if the used id is included in the new dependencies as a dependency
    // without a list of options to make more special abilities possible
    | (Many(_), Some(active)) =>
      // If a Some, it is the index in the list of new dependencies where we can
      // put the active dependency instead
      let index =
        Ley.List.findIndex(
          (newx: Hero.styleDependency) =>
            switch (newx.id) {
            | One(id) => id === active
            | Many(_) => false
            },
          newxs,
        );

      switch (index) {
      | Some(index) => (
          Ley.List.Index.modifyAt(
            index,
            (newx: Hero.styleDependency) => {...newx, active: Some(active)},
            newxs,
          ),
          {...x, active: None},
        )
      | None => (newxs, x)
      };
    | _ => (newxs, x)
    };

  /**
   * `generateStyleDependencies heroSpecialAbilities styleSpecialAbility`
   * returns generated style dependencies for a style special ability.
   */
  let generateStyleDependencies =
      (heroSpecialAbilities, styleSpecialAbility: Static.SpecialAbility.t) =>
    styleSpecialAbility.extended
    <&> (
      extended =>
        extended
        |> Ley.List.map((extendedId) =>
             (
               {id: extendedId, active: None, origin: styleSpecialAbility.id}: Hero.styleDependency
             )
           )
        |> (
          xs =>
            switch (Id.specialAbilityFromInt(styleSpecialAbility.id)) {
            // For this style, the user must choose between two special
            // abilities to be an extended special ability.
            | ScholarDesMagierkollegsZuHoningen =>
              Ley.IntMap.lookup(styleSpecialAbility.id, heroSpecialAbilities)
              >>= (
                (x: Hero.Activatable.t) => x.active |> Ley.Option.listToOption
              )
              >>= (x => Ley.List.Safe.atMay(x.options, 1))
              |> (
                fun
                | Some(`SpecialAbility(id)) => [
                    {
                      Hero.id: One(id),
                      active: None,
                      origin: styleSpecialAbility.id,
                    },
                    ...xs,
                  ]
                | Some(_)
                | None => xs
              )
            | _ => xs
            }
        )
    );

  /**
   * Adds extended special ability dependencies if the passed entry is a style
   * special ability.
   */
  let addStyleExtendedSpecialAbilityDependencies = (styleSpecialAbility, hero) =>
    liftM2(
      ((get, set), newxs) =>
        hero
        |> get
        |> Ley.List.mapAccumL(moveActiveInListToNew, newxs)
        |> (((xs1, xs2)) => xs1 @ xs2)
        |> (xs => set(xs, hero)),
      getStyleDependenciesAcc(styleSpecialAbility),
      generateStyleDependencies(hero.specialAbilities, styleSpecialAbility),
    )
    |> Ley.Option.fromOption(hero);
  //
  // const getIndexForExtendedSpecialAbilityDependency =
  //   (wiki_entry: Record<SpecialAbility>) =>
  //   (xs: List<Record<StyleDependency>>) =>
  //
  //         // Checks if requested entry is plain dependency
  //     alt_ (findIndex (pipe (SDA.id, equals<string | List<string>> (SAA.id (wiki_entry))))
  //                     (xs))
  //
  //         /**
  //           * Otherwise check if the requested entry is part of a list of
  //           * options.
  //           */
  //         (() => findIndex ((e: ListI<typeof xs>) => {
  //                             const e_id = SDA.id (e)
  //
  //                             return isList (e_id)
  //                               && elem (SAA.id (wiki_entry)) (e_id)
  //                           })
  //                           (xs))
  //
  // /**
  //  * Modifies a `StyleDependency` object to show a extended special ability has
  //  * been added.
  //  * @param hero Dependent instances state slice.
  //  * @param wiki_entry The special ability you want to modify a dependency for.
  //  * @returns Changed state slice.
  //  */
  // export const addExtendedSpecialAbilityDependency =
  //   (wiki_entry: Record<SpecialAbility>) =>
  //   (hero: HeroModelRecord): HeroModelRecord =>
  //     fromMaybe
  //       (hero)
  //       (fmap ((l: Lens_<HeroModelRecord, List<Record<StyleDependency>>>) =>
  //               over (l)
  //                   (xs =>
  //                     modifyAt
  //                       (fromMaybe
  //                         (-1)
  //                         (getIndexForExtendedSpecialAbilityDependency (wiki_entry)
  //                                                                     (xs)))
  //                       (set (StyleDependencyL.active) (Just (SAA.id (wiki_entry))))
  //                       (xs))
  //                   (hero))
  //             (lensByExtended (wiki_entry)))
  //
  // /**
  //  * A combination of `addStyleExtendedSpecialAbilityDependencies` and
  //  * `addExtendedSpecialAbilityDependency`.
  //  */
  // export const addAllStyleRelatedDependencies =
  //   (wiki_entry: Record<SpecialAbility>) =>
  //     pipe (
  //       addStyleExtendedSpecialAbilityDependencies (wiki_entry),
  //       addExtendedSpecialAbilityDependency (wiki_entry)
  //     )
  //
  // /**
  //  * Split the objects from the ability to to be removed (`fst`) and remaining
  //  * (`snd`) objects.
  //  */
  // const getSplittedRemainingAndToRemove =
  //   (styleId: string) =>
  //     partition<Record<StyleDependency>> (pipe (SDA.origin, equals (styleId)))
  //
  // /**
  //  * Checks if there is a second object to move the active
  //  * dependency
  //  */
  // const checkForAlternativeIndex =
  //   (dependency: Record<StyleDependency>):
  //   (leftItems: List<Record<StyleDependency>>) => number =>
  //     pipe (
  //       findIndex ((e: Record<StyleDependency>) => {
  //                   const current_id = SDA.id (e)
  //                   const current_active = SDA.active (dependency)
  //
  //                   // If no List, the ids must be equal
  //                   if (typeof current_id === "string") {
  //                     return equals (current_active) (Just (current_id))
  //                   }
  //
  //                   // Must be in List but List must not be used
  //                   return isJust (current_active)
  //                     && elem (fromJust (current_active)) (current_id)
  //                     && isNothing (SDA.active (e))
  //                 }),
  //       fromMaybe (-1)
  //     )
  //
  // /**
  //  * Removes extended special ability dependencies if the passed entry is a style
  //  * special ability.
  //  * @param hero Dependent instances state slice.
  //  * @param instance The special ability you want to remove extended entry
  //  * dependencies for.
  //  * @returns Changed state slice.
  //  */
  // const removeStyleExtendedSpecialAbilityDependencies =
  //   (wiki_entry: Record<SpecialAbility>) =>
  //   (hero: HeroModelRecord): HeroModelRecord =>
  //     fromMaybe
  //       (hero)
  //       (fmap ((l: Lens_<HeroModelRecord, List<Record<StyleDependency>>>) =>
  //               over (l)
  //                   (xs => {
  //                     const splitted =
  //                       getSplittedRemainingAndToRemove (SAA.id (wiki_entry))
  //                                                       (xs)
  //
  //                     const itemsToRemove = fst (splitted)
  //                     const leftItems = snd (splitted)
  //
  //                     return pipe_ (
  //                       itemsToRemove,
  //                       filter (pipe (SDA.active, isJust)),
  //                       foldr ((d: Record<StyleDependency>) =>
  //                               modifyAt (checkForAlternativeIndex (d) (leftItems))
  //                                         (set (StyleDependencyL.active) (SDA.active (d))))
  //                             (leftItems)
  //                     )
  //                   })
  //                   (hero))
  //             (lensByStyle (wiki_entry)))
  //
  // /**
  //  * Modifies a `StyleDependency` object to show a extended special ability has
  //  * been removed.
  //  * @param hero Dependent instances state slice.
  //  * @param wiki_entry The special ability you want to modify a dependency for.
  //  * @returns Changed state slice.
  //  */
  // const removeExtendedSpecialAbilityDependency =
  //   (wiki_entry: Record<SpecialAbility>) =>
  //   (hero: HeroModelRecord): HeroModelRecord =>
  //     fromMaybe
  //       (hero)
  //       (fmap ((l: Lens_<HeroModelRecord, List<Record<StyleDependency>>>) =>
  //               over (l)
  //                   (xs => modifyAt
  //                       (fromMaybe
  //                         (-1)
  //                         (getIndexForExtendedSpecialAbilityDependency (wiki_entry)
  //                                                                     (xs)))
  //                       (set (StyleDependencyL.active) (Nothing))
  //                       (xs))
  //                   (hero))
  //             (lensByExtended (wiki_entry)))
  //
  // /**
  //  * A combination of `removeStyleExtendedSpecialAbilityDependencies` and
  //  * `removeExtendedSpecialAbilityDependency`.
  //  */
  // export const removeAllStyleRelatedDependencies =
  //   (wiki_entry: Record<SpecialAbility>) =>
  //     pipe (
  //       removeStyleExtendedSpecialAbilityDependencies (wiki_entry),
  //       removeExtendedSpecialAbilityDependency (wiki_entry)
  //     )
  //
  // /**
  //  * Return flat array of available extended special abilities' IDs.
  //  * @param xs List of set extended special ability objects.
  //  */
  // const getAvailableExtendedSpecialAbilities =
  //   concatMap<Record<StyleDependency>, string>
  //     (e => {
  //       if (isNothing (SDA.active (e))) {
  //         const current_id = SDA.id (e)
  //
  //         return isList (current_id) ? current_id : pure (current_id)
  //       }
  //
  //       return empty
  //     })
  //
  // /**
  //  * Calculates a list of available Extended Special Abilties. The availability is
  //  * only based on bought Style Special Abilities, so (other) prerequisites have
  //  * to be checked separately.
  //  * @param styleDependencies
  //  */
  // export const getAllAvailableExtendedSpecialAbilities =
  //   foldr (pipe (getAvailableExtendedSpecialAbilities, append)) (empty)
  //
  //
  // /**
  //  * Checks if the passed special ability is a style and if it is valid to remove
  //  * based on registered extended special abilities.
  //  * @param state Dependent instances state slice.
  //  * @param entry The special ability to check.
  //  */
  // export const isStyleValidToRemove =
  //   (hero: HeroModelRecord):
  //   (mwiki_entry: Maybe<Record<SpecialAbility>>) => boolean =>
  //     pipe (
  //       fmap (
  //         (wiki_entry: Record<SpecialAbility>) =>
  //           and (fmap ((l: Lens_<HeroModelRecord, List<Record<StyleDependency>>>) => {
  //                       const splitted =
  //                         getSplittedRemainingAndToRemove (SAA.id (wiki_entry))
  //                                                         (view (l) (hero))
  //
  //                       const itemsToRemove = fst (splitted)
  //                       const leftItems = snd (splitted)
  //
  //                       return pipe (
  //                               filter<Record<StyleDependency>> (pipe (SDA.active, isJust)),
  //                               all (pipe (flip (checkForAlternativeIndex) (leftItems), gt (-1)))
  //                             )
  //                             (itemsToRemove)
  //                     })
  //                     (lensByStyle (wiki_entry)))
  //       ),
  //       or
  //     ) type StyleDependenciesLens = Lens_<HeroModelRecord, List<Record<StyleDependency>>>
  //
  // export type StyleDependencyStateKeys = "combatStyleDependencies"
  //                                     | "magicalStyleDependencies"
  //                                     | "blessedStyleDependencies"
  //                                     | "skillStyleDependencies"
  //
  // /**
  //  * Checks if the given entry is a Style Special Ability and which state key it
  //  * belongs to.
  //  */
  // const lensByStyle =
  //   (x: Record<SpecialAbility>): Maybe<StyleDependenciesLens> => {
  //     switch (SAA.gr (x)) {
  //       case SpecialAbilityGroup.CombatStylesArmed:
  //       case SpecialAbilityGroup.CombatStylesUnarmed:
  //         return Just (HL.combatStyleDependencies)
  //
  //       case SpecialAbilityGroup.MagicalStyles:
  //         return Just (HL.magicalStyleDependencies)
  //
  //       case SpecialAbilityGroup.BlessedStyles:
  //         return Just (HL.blessedStyleDependencies)
  //
  //       case SpecialAbilityGroup.SkillStyles:
  //         return Just (HL.skillStyleDependencies)
  //
  //       default:
  //         return Nothing
  //     }
  //   }
  //
  // /**
  //  * Checks if the given entry is an Extended Special Ability and which state key
  //  * it belongs to.
  //  */
  // const lensByExtended =
  //   (x: Record<SpecialAbility>): Maybe<StyleDependenciesLens> => {
  //     switch (SAA.gr (x)) {
  //       case SpecialAbilityGroup.CombatExtended:
  //         return Just (HL.combatStyleDependencies)
  //
  //       case SpecialAbilityGroup.MagicalExtended:
  //         return Just (HL.magicalStyleDependencies)
  //
  //       case SpecialAbilityGroup.KarmaExtended:
  //         return Just (HL.blessedStyleDependencies)
  //
  //       case SpecialAbilityGroup.SkillExtended:
  //         return Just (HL.skillStyleDependencies)
  //
  //       default:
  //         return Nothing
  //     }
  //   }
  //
  // const moveActiveInListToNew: (newxs: List<Record<StyleDependency>>) =>
  //                             (x: Record<StyleDependency>) =>
  //                             Pair<List<Record<StyleDependency>>, Record<StyleDependency>> =
  //   newxs => x => {
  //     const current_id = SDA.id (x)
  //     const current_active = SDA.active (x)
  //
  //     // If the dependency has got a list of possible ids and
  //     // is used, we check if the used id is included in the
  //     // new dependencies as a dependency without a list of
  //     // options to make more special abilities possible
  //     if (isList (current_id) && isJust (current_active)) {
  //       const index =
  //         findIndex (pipe (
  //                           SDA.id,
  //                           equals,
  //                           thrush (fromJust (current_active))
  //                         ))
  //                   (newxs)
  //
  //       if (isJust (index)) {
  //         return Pair (
  //           modifyAt (fromJust (index))
  //                   (set (StyleDependencyL.active)
  //                         (current_active))
  //                   (newxs),
  //           set (StyleDependencyL.active)
  //               (Nothing)
  //               (x)
  //         )
  //       }
  //     }
  //
  //     return Pair (newxs, x)
  //   }
  //
  //
  // const getStyleDependencies =
  //   (style_special_ability: Record<SpecialAbility>) =>
  //   (hero: HeroModelRecord): Maybe<List<Record<StyleDependency>>> => {
  //     const styleId = SAA.id (style_special_ability)
  //
  //     return pipe_ (
  //       style_special_ability,
  //       SAA.extended,
  //       fmap (pipe (
  //         map (x => StyleDependency ({ id: x, origin: styleId })),
  //         xs => {
  //           switch (styleId) {
  //             case SpecialAbilityId.scholarDesMagierkollegsZuHoningen:
  //               return pipe_ (
  //                 hero,
  //                 HA.specialAbilities,
  //                 lookup (SpecialAbilityId.scholarDesMagierkollegsZuHoningen),
  //                 bindF (pipe (ADA.active, listToMaybe)),
  //                 bindF (AOA.sid2),
  //                 misStringM,
  //                 maybe (xs) (id => cons (xs) (StyleDependency ({ id, origin: styleId })))
  //               )
  //
  //             default:
  //               return xs
  //           }
  //         }
  //       ))
  //     )
  //   }
  //
  //
  // /**
  //  * Adds extended special ability dependencies if the passed entry is a style
  //  * special ability.
  //  * @param hero Dependent instances state slice.
  //  * @param wiki_entry The special ability you want to add extended entry
  //  * dependencies for.
  //  * @returns Changed state slice.
  //  */
  // export const addStyleExtendedSpecialAbilityDependencies =
  //   (wiki_entry: Record<SpecialAbility>) =>
  //   (hero: HeroModelRecord): HeroModelRecord => {
  //     const ml = lensByStyle (wiki_entry)
  //
  //     const mnewxs = getStyleDependencies (wiki_entry) (hero)
  //
  //     type DependencyList = List<Record<StyleDependency>>
  //
  //     return fromMaybe (hero)
  //                     (liftM2 ((l: StyleDependenciesLens) => (newxs: DependencyList) =>
  //                               over (l)
  //                                     (pipe (
  //                                       mapAccumL (moveActiveInListToNew)
  //                                                 (newxs),
  //                                       uncurry (append)
  //                                     ))
  //                                     (hero))
  //                             (ml)
  //                             (mnewxs))
  //   }
  //
  // const getIndexForExtendedSpecialAbilityDependency =
  //   (wiki_entry: Record<SpecialAbility>) =>
  //   (xs: List<Record<StyleDependency>>) =>
  //
  //         // Checks if requested entry is plain dependency
  //     alt_ (findIndex (pipe (SDA.id, equals<string | List<string>> (SAA.id (wiki_entry))))
  //                     (xs))
  //
  //         /**
  //           * Otherwise check if the requested entry is part of a list of
  //           * options.
  //           */
  //         (() => findIndex ((e: ListI<typeof xs>) => {
  //                             const e_id = SDA.id (e)
  //
  //                             return isList (e_id)
  //                               && elem (SAA.id (wiki_entry)) (e_id)
  //                           })
  //                           (xs))
  //
  // /**
  //  * Modifies a `StyleDependency` object to show a extended special ability has
  //  * been added.
  //  * @param hero Dependent instances state slice.
  //  * @param wiki_entry The special ability you want to modify a dependency for.
  //  * @returns Changed state slice.
  //  */
  // export const addExtendedSpecialAbilityDependency =
  //   (wiki_entry: Record<SpecialAbility>) =>
  //   (hero: HeroModelRecord): HeroModelRecord =>
  //     fromMaybe
  //       (hero)
  //       (fmap ((l: Lens_<HeroModelRecord, List<Record<StyleDependency>>>) =>
  //               over (l)
  //                   (xs =>
  //                     modifyAt
  //                       (fromMaybe
  //                         (-1)
  //                         (getIndexForExtendedSpecialAbilityDependency (wiki_entry)
  //                                                                     (xs)))
  //                       (set (StyleDependencyL.active) (Just (SAA.id (wiki_entry))))
  //                       (xs))
  //                   (hero))
  //             (lensByExtended (wiki_entry)))
  //
  // /**
  //  * A combination of `addStyleExtendedSpecialAbilityDependencies` and
  //  * `addExtendedSpecialAbilityDependency`.
  //  */
  // export const addAllStyleRelatedDependencies =
  //   (wiki_entry: Record<SpecialAbility>) =>
  //     pipe (
  //       addStyleExtendedSpecialAbilityDependencies (wiki_entry),
  //       addExtendedSpecialAbilityDependency (wiki_entry)
  //     )
  //
  // /**
  //  * Split the objects from the ability to to be removed (`fst`) and remaining
  //  * (`snd`) objects.
  //  */
  // const getSplittedRemainingAndToRemove =
  //   (styleId: string) =>
  //     partition<Record<StyleDependency>> (pipe (SDA.origin, equals (styleId)))
  //
  // /**
  //  * Checks if there is a second object to move the active
  //  * dependency
  //  */
  // const checkForAlternativeIndex =
  //   (dependency: Record<StyleDependency>):
  //   (leftItems: List<Record<StyleDependency>>) => number =>
  //     pipe (
  //       findIndex ((e: Record<StyleDependency>) => {
  //                   const current_id = SDA.id (e)
  //                   const current_active = SDA.active (dependency)
  //
  //                   // If no List, the ids must be equal
  //                   if (typeof current_id === "string") {
  //                     return equals (current_active) (Just (current_id))
  //                   }
  //
  //                   // Must be in List but List must not be used
  //                   return isJust (current_active)
  //                     && elem (fromJust (current_active)) (current_id)
  //                     && isNothing (SDA.active (e))
  //                 }),
  //       fromMaybe (-1)
  //     )
  //
  // /**
  //  * Removes extended special ability dependencies if the passed entry is a style
  //  * special ability.
  //  * @param hero Dependent instances state slice.
  //  * @param instance The special ability you want to remove extended entry
  //  * dependencies for.
  //  * @returns Changed state slice.
  //  */
  // const removeStyleExtendedSpecialAbilityDependencies =
  //   (wiki_entry: Record<SpecialAbility>) =>
  //   (hero: HeroModelRecord): HeroModelRecord =>
  //     fromMaybe
  //       (hero)
  //       (fmap ((l: Lens_<HeroModelRecord, List<Record<StyleDependency>>>) =>
  //               over (l)
  //                   (xs => {
  //                     const splitted =
  //                       getSplittedRemainingAndToRemove (SAA.id (wiki_entry))
  //                                                       (xs)
  //
  //                     const itemsToRemove = fst (splitted)
  //                     const leftItems = snd (splitted)
  //
  //                     return pipe_ (
  //                       itemsToRemove,
  //                       filter (pipe (SDA.active, isJust)),
  //                       foldr ((d: Record<StyleDependency>) =>
  //                               modifyAt (checkForAlternativeIndex (d) (leftItems))
  //                                         (set (StyleDependencyL.active) (SDA.active (d))))
  //                             (leftItems)
  //                     )
  //                   })
  //                   (hero))
  //             (lensByStyle (wiki_entry)))
  //
  // /**
  //  * Modifies a `StyleDependency` object to show a extended special ability has
  //  * been removed.
  //  * @param hero Dependent instances state slice.
  //  * @param wiki_entry The special ability you want to modify a dependency for.
  //  * @returns Changed state slice.
  //  */
  // const removeExtendedSpecialAbilityDependency =
  //   (wiki_entry: Record<SpecialAbility>) =>
  //   (hero: HeroModelRecord): HeroModelRecord =>
  //     fromMaybe
  //       (hero)
  //       (fmap ((l: Lens_<HeroModelRecord, List<Record<StyleDependency>>>) =>
  //               over (l)
  //                   (xs => modifyAt
  //                       (fromMaybe
  //                         (-1)
  //                         (getIndexForExtendedSpecialAbilityDependency (wiki_entry)
  //                                                                     (xs)))
  //                       (set (StyleDependencyL.active) (Nothing))
  //                       (xs))
  //                   (hero))
  //             (lensByExtended (wiki_entry)))
  //
  // /**
  //  * A combination of `removeStyleExtendedSpecialAbilityDependencies` and
  //  * `removeExtendedSpecialAbilityDependency`.
  //  */
  // export const removeAllStyleRelatedDependencies =
  //   (wiki_entry: Record<SpecialAbility>) =>
  //     pipe (
  //       removeStyleExtendedSpecialAbilityDependencies (wiki_entry),
  //       removeExtendedSpecialAbilityDependency (wiki_entry)
  //     )
  //
  // /**
  //  * Return flat array of available extended special abilities' IDs.
  //  * @param xs List of set extended special ability objects.
  //  */
  // const getAvailableExtendedSpecialAbilities =
  //   concatMap<Record<StyleDependency>, string>
  //     (e => {
  //       if (isNothing (SDA.active (e))) {
  //         const current_id = SDA.id (e)
  //
  //         return isList (current_id) ? current_id : pure (current_id)
  //       }
  //
  //       return empty
  //     })
  //
  // /**
  //  * Calculates a list of available Extended Special Abilties. The availability is
  //  * only based on bought Style Special Abilities, so (other) prerequisites have
  //  * to be checked separately.
  //  * @param styleDependencies
  //  */
  // export const getAllAvailableExtendedSpecialAbilities =
  //   foldr (pipe (getAvailableExtendedSpecialAbilities, append)) (empty)
  //
  //
  // /**
  //  * Checks if the passed special ability is a style and if it is valid to remove
  //  * based on registered extended special abilities.
  //  * @param state Dependent instances state slice.
  //  * @param entry The special ability to check.
  //  */
  // export const isStyleValidToRemove =
  //   (hero: HeroModelRecord):
  //   (mwiki_entry: Maybe<Record<SpecialAbility>>) => boolean =>
  //     pipe (
  //       fmap (
  //         (wiki_entry: Record<SpecialAbility>) =>
  //           and (fmap ((l: Lens_<HeroModelRecord, List<Record<StyleDependency>>>) => {
  //                       const splitted =
  //                         getSplittedRemainingAndToRemove (SAA.id (wiki_entry))
  //                                                         (view (l) (hero))
  //
  //                       const itemsToRemove = fst (splitted)
  //                       const leftItems = snd (splitted)
  //
  //                       return pipe (
  //                               filter<Record<StyleDependency>> (pipe (SDA.active, isJust)),
  //                               all (pipe (flip (checkForAlternativeIndex) (leftItems), gt (-1)))
  //                             )
  //                             (itemsToRemove)
  //                     })
  //                     (lensByStyle (wiki_entry)))
  //       ),
  //       or
  //     )
};
